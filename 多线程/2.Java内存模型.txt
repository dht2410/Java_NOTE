### Java内存模型

#### 1. 基础

两个关键问题：

- 线程之间如何**通信**（共享内存和消息传递，Java采用共享内存）
- 线程之间如何**同步**（共享内存，同步是显示的，必须显示指定谁在谁前）

线程通信步骤：

1. 线程A把本地内存中更新过的共享变量刷新到主内存中
2. 线程B到主内存中读取线程A更新过的变量

#### 2. 重排序及happens-before

- 重排序是指编译器和处理器为了优化程序而对指令序列进行重新排列的手段。
- 重排序不改变具有数据依赖性的两个操作的顺序。两个操作访问同一个变量，且其中一个为写操作。
- 多线程的重排序会出现问题。例如对控制依赖的重排序。

#### 3. 顺序一致性

数据竞争：在一个线程中写一个变量，在另一个线程读一个变量，而且写和读没有通过同步来排序。

顺序一致性模型：第一，一个线程的所有操作必须按照程序的顺序来执行；第二，不论程序是否同步，所有线程都只能看到一个单一的操作执行顺序，每个操作必须原子执行且必须对所有线程可见。

JMM不保证顺序一致性，未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序可能不一致。线程A看到的线程B与线程B看自己的执行顺序可能不一致。

在JMM中程序正确同步

```java
class SynchronizedExample{
    int a=0;
    boolean flag = false;
    public synchronized void writer(){
        a=1;                    //1
        flay=true;              //2
    }
    public synchronized void reader(){
        if(flag){              //3
            int i=a*a;         //4
        }
    }
}
```

先writer()后reader()，在JMM中，1和2先执行，3和4后执行，但1和2的顺序可以重排，3和4的顺序可以重排。

JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。

#### 4. volatile的内存语义

（1）volatile的特性

1. **可见性。**对一个volatile变量的读，总能看到任意线程对这个volatile变量最后的写入。
2. **原子性。**对任意单个volatile变量的读/写具有原子性（类似于加了一个普通的锁），但类似于volatile++这种复合操作不具有原子性。
3. **禁止指令重排。**

（2）volatile写—读的内存含义

volatile写：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。

volatile读：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来要从主内存中读取共享变量。

总结：线程A写一个volatile变量，实质上是线程A向接下来读这个变量的线程发了消息；线程B读这个变量，实质上是接受到了这个消息。**这个过程实质上是线程A通过主内存向线程B发送消息。**

（3）volatile内存语义的实现

1. volatile写之前的操作不会被编译器重排序到volatile写之后。
2. volatile读之后的操作不会被编译器重排序到volatile读之前。