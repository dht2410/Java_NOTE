### Java并发的底层实现原理

##### 1. volatile

volatile是轻量级的synchronized，保证了共享变量的可见性。可见性即，当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。轻量级为它不会引起线程的上下文切换。

volatile修饰的共享变量：

1. 当转换成汇编码时会增加lock前缀指令。**lock前缀指令会引起处理器缓存回写到内存。**
2. 一个处理器的缓存回写到内存会导致其他处理器的缓存无效。下次读取的时候应去内存读。每个CPU都有自己的cache line.

##### 2. synchronized

synchronized实现基础：**Java中的每个对象都可作为锁**。

1. 对于普通同步方法，锁是当前实例对象。
2. 对于静态同步方法，锁是当前类的Class对象。
3. 对于同步方法块，锁是synchronized括号里匹配的对象。

JVM基于进入和退出Monitor对象来实现同步。monitorenter指令再编译后插到同步代码块的开始位置，monitorexit插到结束和异常处。任何对象都有与之对应的monitor。线程执行到monitorenter指令时，首先尝试获取对象的monitor.

synchronized锁信息在对象的Mark Word，即对象头里。

锁一共有4种状态：**无锁状态、偏向锁状态、轻量锁状态和重量锁状态**。这几个状态会随着竞争情况逐渐升级，但不可降级。

##### （1）偏向锁

大多数情况下，锁总是由同一线程多次获得。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID。**在以后线程进入和退出时不需要加锁和解锁，只需要简单测试对象头里的偏向锁**。测试成功，表示线程获取了锁；测试失败，再看Mark Word偏向锁标识是否设置为1，如果没有则使用CAS竞争锁，如果设置为1，则尝试使用CAS将对象头的偏向锁指向当前线程。

**偏向锁使用了等到竞争才会释放的机制，当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。**

优点：加锁和解锁不需要额外的消耗。

##### （2）轻量级锁

线程在执行同步块前，JVM会先在当前线程的栈帧中创建空间将对象头中的Mark Word复制到锁记录中，即Displaced Mark Word。

尝试使用CAS将对象头中的Mark Word替换为指向栈帧中锁记录的指针。如果成功，则线程获取该锁，如果失败，则当前线程使用自旋来获取锁。

解锁：当前线程尝试用原子的CAS操作将Displaced Mark Word替换回对象头，如果成功，则表示没有竞争，如果失败，则表示当前锁存在竞争，锁就会膨胀成重量级锁。

优点：竞争的线程不会阻塞。



##### CAS：compare and swap

CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。当A和V不同时，则说明被其他线程修改过，自己的此次修改失败。



##### 3. 原子操作

处理器实现原子操作：

1. **使用总线锁保证原子性**：CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。总线锁就是使用处理器提供的一个LOCK信号，这时其他处理器的请求将被阻塞。
2. **使用缓存锁保证原子性**：缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行数据时，会使缓存行无效。

CAS实现原子操作的三大问题：

1. ABA问题，由A变为B再变为A，认为不变。解决为增加版本号
2. 循环时间开销大
3. 只能保证一个变量的原子操作

使用锁机制实现原子操作：

​	除了偏向锁，JVM实现锁的方式都用了**循环CAS**，即当一个线程想进入同步块的时候使用循环CAS获取锁，退出的时候使用循环CAS释放锁。