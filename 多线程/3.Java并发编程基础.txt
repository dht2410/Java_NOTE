### 并发编程

一个Java程序的运行不仅是main()的运行，而是main()线程和其他多个线程同时运行。

##### 1. 线程优先级

现代操作系统基本采用**时分**的形式调度运行的线程。操作系统划分出一个个时间片，时间片用完后便进行线程调度。

线程状态：

1. NEW：初始状态，线程被构建，但还没有调用start()方法
2. RUNNABLE：运行状态，在操作系统中就绪和运行两种状态都称为运行中
3. BLOCKED：阻塞状态，表示阻塞于锁
4. WAITING：等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作
5. TIME_WAITING：超时等待状态，不同于WAITING，可以在指定的时间自行返回
6. TERMINATED：终止状态，当前线程已经执行完毕

Daemon线程（守护线程）：

当一个Java虚拟机中不存在非Daemon线程时，JVM将退出。

##### 2. 启动和终止线程

（1)构造线程

​		在运行线程前首先要构造一个线程对象。一个新构造的线程是由其parent来进行空间分配的，parent就是currentThread()，而child线程继承了parent是否为Daemon，优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。

（2）启动线程

调用start()方法就可以启动线程。start()方法含义为：当前线程（parent线程）告知JVM，只要线程规划器空闲，应立即启动调用start()方法的线程。

（3）

suspend()、resume()、stop()等方法被弃用，是因为suspend()会占用资源进入暂停，有可能造成死锁；stop()有可能在终结一个线程时不保证占用的资源被释放掉。

（4）安全终止线程

通过main()线程调用interrupt()方法或在线程中设置标志位的方式，可以安全地终止线程

##### 3. 线程间通信

（1）volatile和synchronized关键字

volatile修饰的字段，就是告知程序对该变量的访问要从共享内存中获得数据，对该变量的改写要刷进共享内存

synchronized的本质是对对象监视器的获取。任何对象都有监视器。只有获得该对象的监视器才能进入同步块，没有获得就会在同步块入口处BLOCKED。

获取线程失败后，线程进入同步队列，线程状态变为BLOCKED。当获得锁的前驱释放了锁，线程被唤醒。

（2）等待/通知机制

任何对象都有的wait()和notify()方法。

在线程A中执行到obj.wait()，表明线程A进入WAITING状态，等待其他线程唤醒。

线程B执行到同一个obj的obj.notify()方法，表明唤醒在这个obj上等待的线程A。

线程A和B通过对象obj来进行交互。

细节：

1. 使用wait()、notify()、notifyAll()方法时，需要先对调用对象加锁。
2. 调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放到等待队列。
3. notify()和notifyAll()方法调用后，wait()方法等待的线程不一定从wait()方法返回，需要notify()的线程释放锁
4. notify()方法是将在等待队列中的线程（WAITING的线程）移入同步队列（BLOCKED的线程），被移动的线程状态变为BLOCKED
5. wait()方法返回的前提是获得了对象的锁

范式：

等待方（消费者）：

​	1）获得对象的锁

​	2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件

​	3）条件满足则执行对应逻辑

​	伪代码：

```java
synchronized (对象){
    while(条件不满足){
        对象.wait();
    }
    对应处理逻辑；
}
```

通知方（生产者）：

​	1）获得对象的锁

​	2）改变条件

​	3）通知等待在对象上的线程

​	伪代码：

```java
synchronized(对象){
    改变条件
    对象.notifyAll();
}
```

（3）管道输入/输出流

用于线程之间的数据传输，传输的媒介为内存。

（4）Thread.join()

在线程A中调用threadB.join()，即线程A等待threadB终止才会从join()方法返回。

（5）ThreadLocal的使用

线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。