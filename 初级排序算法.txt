排序
比较次数和交换次数

选择排序：
	搜索数组中的最小元素，然后将其与第一个元素交换，之后从第二个元素开始，以此类推；
	比较次数~N方/2
	交换次数~N，和数组大小成线性关系，为所有排序算法中最少

插入排序：
	对于要排入的某个元素来说，其左边的元素已经从小到大排好，如果左边的元素比这个元素大，则交换；
	适用于有序或者接近有序的数组
	最好：比较N-1次，交换N-1次
	最差：比较~N方/2，交换~N方/2
	for(int i=0;i<a.length;i++){
            for(int j=i;j>0&&less(a[j],a[j-1]);j--){
                exch(a,j,j-1);
            }
        }

希尔排序：
	分成h个子数组，对于子数组进行插入排序，最后对数组进行插入排序；
	优势：子数组规模小，最后数组于部分有序的，都适用于插入排序
	while (h<N/3)
            h=h*3+1;
        while (h>=1){
            for(int i=h;i<N;i++){
                for(int j=i;j>=h&&less(a[j],a[j-h]);j-=h){
                    exch(a,j,j-h);
                }
            }
            h=h/3;
        }

2.1.4 出列排序
	将两张牌中较小的放到底部，这样经过N-1次比较，最上面出现的是最大的牌，把它放到底部；
	再进行一遍循环，经过N-2次比较，最上面出现的是第二大的牌，把它放到底部；
	。。。

2.1.25 不需要交换的插入排序
	public static void sort(Comparable[] a) {
		int N = a.length;
		for (int i = 1; i < N; i++) {
			Comparable temp = a[i];
			int j = i;
			for (; j > 0 && less(temp, a[j - 1]); j--) {
				a[j] = a[j - 1];
			}
			a[j] = temp;
		}
	}
	
