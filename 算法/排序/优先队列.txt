优先队列
执行的操作主要为插入元素和删除最大元素

基于数据结构堆实现，这两个操作时间复杂度都为logN，而基于线性的结构的时间复杂度为N和1

优先队列和堆的关系：优先队列可以用顺序结构或堆来实现。一般堆的效果更好。

堆有序:二叉树的每个节点都大于等于他的子节点
推论：任意节点向上都能得到非递减的元素，任意节点向下都能得到非递增的元素

一棵堆有序的完全二叉树，用数组就可以表示，先定下根节点，根节点在位置1，子节点为2和3，再跟节点为4、5、6、7
在一个堆中，k结点的父结点位置为k/2向下取整，k结点的子结点为k和k+1
构建长度为N+1的私有数组pq[]，pq[0]不使用
如果pq[0]使用，则两个子结点分别为pq[2k+1]和pq[2k+2]
swim(int k) 将a[k]上浮上去，使堆有序
sink(int k) 将a[k]下沉下去，使堆有序

下沉代码：
    private void sink(int k){
        while (2*k<=M){
            int j=2*k;
            if(j<M&&less(j,j+1)) j++;
            if(less(k,j)) exch(k,j);
            k=j;
        }
    }
	
用N个给定元素数组构造一个堆？
方法1：只需从左到右遍历数组，用swim()保证指针左侧的所有元素堆有序
方法2：从右向左遍历，只需从N/2处向前，对每个元素调用sink()，这样只用遍历N/2个。递归。当
		一个节点的两个子结点已经是堆，那么在该结点调用sink()也会使其变为堆

堆排序算法：
public static void sort(Comparable[] a){
	int N=a.length;
	//先进行堆排序
	for(int k=N/2;k>=1;k--){
		sink(a,k,N);
	}
	//再进行逐个删除，从大到小
	while(N>1){
		exch(a,1,N--);
		sink(a,1,N);
	}
}

优势：在最坏情况下也能保证2NlgN次比较和恒定的额外空间。
	  在现代应用程序中应用多，能在插入操作和删除最大元素操作混合的动态场景保证对数级别运算。
劣势：不进行相邻元素的比较，缓存未命中次数多余快速、归并甚至是希尔。现代系统的许多应用很少使用。