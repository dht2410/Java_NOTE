线程
老的服务器每次建立一个连接都会开一个进程，建立和销毁的开销都很大
thread表示一个单独、独立的执行路径
Thread是lang包中的一个类
两种方式：
1.派生Thead类
2.实现Runnable接口
Thread t= new Thread(Runnable r);
t.start();  //程序开一个线程，执行r中的run方法

如何从线程返回信息
要保证在run方法执行结束后，才调用需要通过run方法获得的数据
解决这个问题，采用回调
具体为让线程结束时反过来调用其创建者的方法，而不是让创建者线程轮询，
run方法中调用该创建者实例变量的方法，该创建者可能实现了某个接口，于是run方法调用该接口规定的方法

Future、Callable和Executor
Callable实现一个带返回值的call()方法，Future接收这个值
ExcutorService service = Executors.newFixedThreadPool(2) //创建两个线程池

同步和异步
同步：多个事物不能同时来，必须一个一个挨着来
异步：相反

同步块
synchronized关键字
synchronized(System.out){
	System.out.println();
}
对System.out对象同步,只对同一个对象同步的代码块同步，同步块写在实现Runnable接口类中

同步方法
在方法中加入synchronized修饰符，相当于synchronized(this)

缺陷：1.VM执行速度  2.死锁的发生  3.并不总是对象本身需要防止同时修改或访问，可能是该实例的字段
	如果该字段是共有的，那么同步该对象，则该字段可能在被别的与该类无关的对象引用，而发生变化

同步的替代方法：
1.变字段为局部变量
2.使用不可变对象
3.将非线程安全的类作为线程安全的类的字段

线程调度和抢占
为了能让一个线程停止或指示其暂停，在其run方法中必须以能够有这种方式

线程的6种状态：新创建、可运行、被阻塞（自己排队等资源）、等待（等待别人的通知）、计时等待、被终止

阻塞
线程停下来等待它没有的资源，就会发生阻塞。常见的是I/O阻塞，因为CPU比I/O快得多

连接线程
t.join();  //等待线程t结束，才往下执行，现在用Excutor和Future可能更容易实现

等待
obj.wait();    //在其他线程调用此对象的notify()方法之前，当前线程等待，所以当前线程要拿到此对象监视器
obj.notify();  //唤醒在此对象监视器上等待的线程，也就是等待obj被激活的线程，上面的当前线程

一旦已经生成足够多的线程来使用计算机所有可用的空闲时间，那么在生成多的线程只会将MIPS和内存浪费


