## 索引和算法

**支持的常见索引：**

- B+树
- 全文索引
- 哈希索引。会根据表的使用情况自动为表生成自适应哈希索引。

**B+树的插入：**

- 按Leaf Page和Index Page是否满来拆
- 为减少磁盘IO，会做旋转操作。即匀给兄弟节点

**B+树的删除：**

- 设置填充因子，最小50%。小于填充因子后和兄弟节点合并

**聚集索引：**

- 按照每张表的主键构造一棵B+树。每张表只能有一个聚集索引
- 并不是物理上连续的，而是逻辑上连续。页之间是双向链表连接，页内的行记录也是双向链表连接
- 对于主键的排序查找和范围查找非常快

**辅助索引：**

- 叶子节点不包含行记录的全部数据。叶子节点除了包含键值外，还包含一个书签。
- 先在辅助索引找到主键。然后通过聚集索引找到行记录。
- 回表
- alter table 表 add index 索引名 （列名，列名...）

**管理索引：**

show index from 表\G;

Cardinality表示不重复记录的预估值，改参数帮助优化器进行查询。

使用ANALYZE TABLE对Cardinality参数进行更改。

**联合索引：**

- 也是按B+树组织
- （a,b）这个联合索引不能用于对b进行索引

**覆盖索引：**

- 通过辅助索引查询主键，则直接用辅助索引就可以，不用聚集索引



当访问的数据占表中数据较大一部分时，优化器选择扫描聚集索引。



## 锁

管理对共享资源的并发访问

不同数据库和不同存储引擎的实现不同

InnoDB提供一致性的非锁定读、行级锁支持。

lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行

两种行级锁：

- 共享锁（S Lock）
- 排他锁（X Lock）

如果对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。如果对表的某一记录上锁，那么表、页都需要上意向锁。

![image-20200609211101014](C:\Users\dht24\AppData\Roaming\Typora\typora-user-images\image-20200609211101014.png)

**一致性非锁定读**

如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会等待行上锁的释放。而是去读行的一个快照数据。快照数据是该行之前版本的数据。

**快照的实现是通过undo段来完成，undo用来在事务中的回滚数据，因此快照数据本身没有额外的开销。**

在不同的事务隔离级别下，读取的方式不同，并不是在每个事务隔离级别下都是采用非锁定的一致性读。**在READ COMMITTED和REPEATABLE READ下采用。**

每行记录可能有多个版本。由此带来的并发控制，称为MVCC，多版本并发控制。

**一致性锁定读**

默认对SELECT操作使用一致性非锁定读。但某些情况下可以对SELECT加锁。

SELECT ... FOR UPDATE      //这样的可以读最新数据

SELECT ... LOCK IN SHARE MODE

另一个事务挂了锁，这时这个事务SELECT可以，但SELECT ... FOR UPDATE不行



### 锁的算法

Record Lock：单个行记录上的锁

Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。防止多个事务将记录插到同一个范围内。

Next-key Lock：前两个之和，解决幻读问题

默认为Next-key Lock，仅在查询的列是唯一索引的情况下会降级成Record Lock。

![image-20200610110244819](C:\Users\dht24\AppData\Roaming\Typora\typora-user-images\image-20200610110244819.png)

### 锁问题

###### （1）脏读

READ UNCOMMITTED 隔离级别会出现脏读，即一个事务还没有提交，另一个事务读到了修改值

###### （2）不可重复读

一个事务，两次查询结果不一致。READ COMMITTED会出现此问题。

###### （3）幻读

多行或少行



**阻塞**

阻塞超时会抛出异常

**死锁**

维护一个锁信息链表和事务等待链表，如果出现回路，则说明死锁。

用DFS搜索。



## 事务

**事务（Transaction）是数据库区别于文件系统的重要特性之一。**

事务把数据库从一种状态转化成另一种状态。

- 原子性（Atomicity）
- 一致性（consistency）
- 隔离性（isolation）.由锁实现
- 持久性（durability）

**redo log保证原子性和持久性，undo log保证一致性。**

内存中的redo log buffer是易失的，磁盘中的redo log file是持久的。

undo存放在undo segment中，物理上在ibdatal中。

undo是逻辑日志，作用：回滚+MVCC



purge

当delete和update发生时，不会直接删除原有的数据。真正完成是purge来。