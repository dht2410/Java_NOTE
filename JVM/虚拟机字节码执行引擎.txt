# 虚拟机字节码执行引擎

输入是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

### 1. 运行时栈帧结构

栈帧，线程私有，一个方法对应一个栈帧

栈帧存储了方法的**局部变量表、操作数栈、动态连接和方法返回地址**

一个线程中方法调用链可能很长，对于执行引擎来说，**只有位于栈顶的栈帧才是有效的**，称为当前帧，与之关联的是当前方法

##### （1）局部变量表

编译为class文件时，已经确定了需要分配的最大容量，在Code属性的max_locals数据项中

以Slot为最小单位，除了long和double类型，其他类型都能存放在一个Slot中，包括基本数据类型和reference和retureAddress。reference指向在堆中的对象起始地址，retureAddress指向一条字节码指令的地址。

虚拟机通过索引定位的方式使用局部变量表，索引值的范围从0到局部变量表最大的Slot数量。**如果是实例方法，则第一位默认放this。**

局部变量表中的Slot可以重用，跳出了作用域后可以被其他变量替代。

局部变量必须被赋值才能使用，和成员变量不同，成员变量会被在准备阶段赋予初始值。

##### （2）操作数栈

操作数栈是一个后入先出的栈，最大深度由编译时Code属性的max_stacks确定

当一个方法开始执行时，操作数栈一开始是空的，在方法执行的过程中，会有入栈和出栈操作

##### （3）动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了方法调用中的动态连接。

##### （4）方法返回地址

两种方法退出方法执行：

- 执行引擎遇到任意一个方法返回的字节码指令，这时候将返回值返回给上层的调用者。称为正常完成出口。
- 方法执行过程中遇到了异常，并且异常没有在方法体内得到处理，就会退出。称为异常完成出口。

方法退出后，需要返回到方法被调用的位置。一般来说，方法退出时，调用者的PC计数器的值可以作为返回地址。

**方法退出的过程相当于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器（线程私有）的值以指向方法调用指令后面的一条指令。**

### 2. 方法调用

一切方法调用在Class文件中存储的都是符号引用，而不是直接引用。需要在类加载期间甚至运行期间才能确定目标方法的直接引用。

##### （1）解析

在类加载阶段就可将符号引用转化为直接引用的方法，包括**静态方法、私有方法、实例构造器和父类方法**。以及**final方法**，因为无法被覆盖。这些方法称为**非虚方法**。称为解析调用。解析调用在编译期间就能完全确定。

分别为invokestatic方法和invokespecial方法

##### （2）分派（dispatch）

1. 静态分派（发生在编译阶段）

   ```java
   Human man = new Man();
   ```

   Human是Man的父类，上述代码中，**Human为变量的静态类型，Man为变量的实际类型**。**编译器重载时是根据变量的静态类型而不是实际类型来重载的**。

   所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是重载。

2. 动态分派（发生在运行阶段）

   在运行期间**根据实际类型确定方法执行版本**的分派过程称为动态分派。

   多态的重写性质与动态分派有关。**重写按实际类型执行。**

   ```java
   Human man = new Man();
   man.sayHello();  //执行的是Man的sayHello方法而不是Human的
   ```

   调用方法的指令为invokevirtual。执行该指令的第一步为找到操作数栈顶的第一个元素所指向对象的实际类型。

3. 单分派和多分派

   方法的接收者：调用方法的对象。

   方法的接收者（**重写**）和方法的参数（**重载**）统称为方法的宗量。**根据分派基于多少种宗量**，可以将分派划分为单分派和多分派。

   静态分派的选取既会依据静态类型，又会依据方法参数。所以**静态分派都是多分派**。

   到了动态分派阶段，由于编译器在静态分派时已经确定了参数类型，于是动态分派只会由此方法的实际接收者决定。因此**动态分派是单分派**。

4. 虚拟机动态分派的实现

   由于动态分派是非常频繁的操作，最常用的稳定优化手段是为类在方法区建立一个**虚方法表**。

   虚方法表中存放各个方法的实际入口地址，如果没有重写父类，则和父类同一方法指向相同的入口地址；如果重写了父类方法，则子类方法会指向自己的入口地址。即，不用往父类去寻找。

##### （3）动态类型语言支持

动态类型语言：类型检查过程在运行期而不是编译期，如JS, Python。

静态类型语言：类型检查过程发生在编译期，如C++, Java.

**动态静态差别在于：Java语言在编译期间已将方法完整的符号引用确定下来，包括此方法定义在哪个具体类型中，方法的名字以及参数顺序、参数类型和返回信息等。而动态语言中，编译时最多确定方法名称、参数、返回值等。**

```java
obj.println("hello world");
```

在Java中，obj在编译时确定静态类型必须为java.io.PrintStream, 实际类型必须实现了PrintStream接口。哪怕obj不是该类型，但它的类中定义了println方法也不会通过编译期间类型检查。但动态语言就不会，变量obj本身没有类型，变量obj的值才有类型。

静态语言优势：稳定严谨，适合大规模

动态语言优势：灵活

invokedynamic待学习



### 3. 基于栈的字节码执行引擎

虚拟机在执行Java代码时都有**解释执行**和**编译执行**两种，在于字节码到机器码的过程

解释执行：逐条将字节码翻译成机器码，逐条执行

即时编译执行：以方法为单位，将字节码翻译为机器码，统一执行

计算1+1

基于栈的指令集：把1和1压入操作数栈，相加，把结果放入栈顶

基于寄存器的指令集：把寄存器的值设为1，再把这个值加上1，结果保存在寄存器中