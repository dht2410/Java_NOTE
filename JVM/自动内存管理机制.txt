Java虚拟机为什么叫虚拟机？
https://blog.csdn.net/qq_34872215/article/details/79660141

内存泄漏：申请的内存空间无法释放。
内存溢出：申请不到空间，因为不够用了。

运行时数据区：
	线程隔离：程序计数器、虚拟机栈+本地方法栈
	线程共享：堆、方法区
	
虚拟机栈（+本地方法栈）：
	每个方法在执行的时候会创建一个栈帧，用于储存局部变量表、操作数栈等
	局部变量表存放基本数据类型、对象引用和returnAddress类型
Java堆：
	此内存区域的唯一目的就是存放对象实例
	可分为新生代和老年代，新生代又能分为：Eden、From Survivor、To Survivor空间，两个Survivor空间保证一个是空的
	可以处于物理上不连续的空间中，逻辑上连续即可
方法区：
	存储被虚拟机加载的类信息、常量、静态变量等（永久代）
	运行时常量池包含在方法区内
直接内存：
	NIO类，引入了基于通道和缓冲区的I/O方式，通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用

对象：
	1.当虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个符号引用，
	  并且检查这个符号引用代表的类是否已被加载、解析和初始化过
	2.确定了类，就确定了对象占用的内存空间。划分内存分为“指针碰撞”和“空闲列表”。
	3.划分内存空间的并发线程安全：
		（1）对分配内存空间的操作进行同步处理
		（2）分配在每个线程的本地线程分配缓存中（TLAB）
对象的内存布局：
	对象在内存中可分为三块区域：对象头、实例数据、对齐填充
	1.对象头：
		（1）存储对象自身的运行时数据，包括哈希码、GC分代年龄、线程持有的锁等，官方称为“Mark Word”
		（2）类型指针。指向它的类元数据的指针，通过类型指针来确定是哪个类的实例。
		（3）如果对象是数组，那么在对象头还有记录数组长度的数据。
	2.实例数据：
		默认分配策略：相同宽度的字段总是被分配到一起。
	3.对齐填充
		HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍。
对象的访问定位：
	通过栈上的Reference数据来操作堆上的具体对象。访问有使用句柄和直接访问两种方式。
	使用句柄：堆中划分出一块作为句柄池。句柄中包含到对象实例数据的指针（指向示例数据，在堆中）和
			  到对象类型数据的指针（类信息，在方法区中）
			  好处是Reference不会被改变，对象移动时只会改变句柄中指向实例数据的指针。
	直接访问：Reference指向对象地址。对象头中的类型指针指向类信息。
			  好处时快速，只用一个指针就可定位对象。

OOM异常（Out of Memory）:
	（1）Java堆溢出：创建了太多的对象。
	（2）Java虚拟机栈和本地方法栈溢出：线程中创建太多变量，达到栈的最大深度，StackOverFlowError
		或创建太多线程，OOM异常
	（3）方法区和运行时常量池溢出：
		关于String.intern()方法：Jdk1.6中，该方法是复制该对象到字符串常量池，容易OOM；1.7及以后，是在常量池记录首次出现的实例引用
		String a="aaa"，直接在堆中创建对象，并把将引用加入常量池；再次出现String b="aaa"，则不会创建对象
	（4）本机直接内存溢出：
		直接内存默认与堆内存最大值一样。由于直接内存导致的内存溢出，Heap Dump文件中不会看到明显的异常，直接或间接使用NIO

==和equals()的区别：
	==比较的是地址，指向的地址相同，则返回true;不同，返回false
	equals()默认和==一样，但可以重写。如String类中的equals方法。


	
	