## Java内存模型与线程

cache解决了处理器与内存速度不匹配的问题，但带来缓存一致性问题。

### 主内存和工作内存

每个线程都有自己的工作内存，线程私有；线程对变量的所有操作都必须在工作内存中操作，而不允许直接操作主内存。线程的工作内存保存了该线程使用的主内存拷贝。内存间相互操作

8种虚拟机必须保证的原子操作：

- lock
- unlock
- read: 把主内存的变量传输到线程工作内存中
- load：把read来的变量放入工作内存的变量副本中
- use
- assign
- store
- write

read和load不能单独出现，store和write不能单独出现

#### volatile

可见性+防止指令重排

volatile只能保证可见性。i++操作并不是原子操作。取值的时候可以保证是真实的，但执行加1的过程中，可能被其他线程获得i。

long和double这两个64位操作，虚拟机规范未要求原子操作，可以将其划分为两个32位操作。因此多个线程共享会出现读到一半值的情况。但商用虚拟机基本上都是把这个操作设置为原子操作。

#### 原子性、可见性、有序性

