# 虚拟机类加载机制

虚拟机**把描述类的文件从Class文件加载到内存**，对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

**运行时类加载**

### 1.类加载的时机

在JVM的生命周期里，每个类只会被加载一次。

类加载的原则：**延迟加载，能少加载就少加载**，因为虚拟机的空间是有限的。

static{}代码块：在类加载的时候执行，仅执行一次，性能优化

```java
class Person{
    private Date birthDate;
     
    public Person(Date birthDate) {
        this.birthDate = birthDate;
    }
    //每次isBornBoomer()方法执行，都会对生成实例对象
    boolean isBornBoomer() {
        Date startDate = Date.valueOf("1997");
        Date endDate = Date.valueOf("2019");
        return birthDate.compareTo(startDate)>=0 && birthDate.compareTo(endDate) < 0;
    }
}
```

```java
class Person{
    private Date birthDate;
    private static Date startDate,endDate;
 
    static{
        startDate = Date.valueOf("1997");
        endDate = Date.valueOf("2019");
    }
     
    public Person(Date birthDate) {
        this.birthDate = birthDate;
    }
     
    boolean isBornBoomer() {
        return birthDate.compareTo(startDate)>=0 && birthDate.compareTo(endDate) < 0;
    }
}
```

### 2.类加载的过程

类的生命周期：加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析三部分统称为连接（linking）. 类加载过程包括前五个。

其中，**加载、验证、准备、初始化和卸载开始的顺序是确定的**。解析可在初始化之后发生。

只对当且仅当什么时候必须初始化做了规定：

- new
- 访问类的静态变量（final修饰则不需要初始化）
- 调用类的静态方法（final修饰则也需要初始化）
- 初始化一个类时，其父类还没有被初始化
- 对类进行反射
- 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。java.exe执行，本质执行main方法时

##### 1.加载

1. 通过一个类的全限定名（类似于绝对路径）来获取定义此类的二进制字节流
2. 将此字节流转化为运行时方法区中的数据结构
3. 在内存中生成这个类的java.lang.Class对象（存储在方法区），作为方法区这个类的访问入口

##### 2.验证

验证二进制字节流是否满足Class文件的格式

1. 文件格式验证。检查Class文件的格式。检查完成后装进方法去，之后的验证都是针对方法区的数据结构来进行。
2. 元数据验证。进行语义校验，对类进行校验。如：看是否满足接口规定的要求
3. 字节码校验。对类的方法体进行分析。
4. 符号引用验证。为解析服务。

##### 3.准备

正式**为类变量分配内存并设置类变量初始值（不是赋值）**的阶段。类变量是static修饰的变量，存储在方法区中，与实例变量不同。初始值是数据类型的零值。

```java
public static int value = 123;
```

value在准备阶段后的初始值是0，而不是123，因为还没有执行Java方法。123在初始化阶段才赋值。

##### 4.解析

将常量池中的**符号引用**替换为**直接引用**的过程。

符号引用：可以是任何形式的字面量，但使用时应无歧义地定位到目标。因为在编译时，并不会确定引用对象加载到内存的地址。所以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型都会指向一个CONSTANT_Utf8_info类型。和虚拟机内存布局无关

直接引用：可以是指向目标的指针，地址偏移量等。和虚拟机内存布局有关

解析动作主要针对：类或接口、字段、类方法、接口方法

###### （1）类的解析

假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，需要3步：

1. 如果C不是数组类型，那**虚拟机将会把代表N的全限定名传递给D的类加载器去加载类C**
2. 如果C时一个数组类型，并且数组的元素也是对象，将会按照第1点的规则加载数组元素类型，接着由虚拟机生成一个代表此数组维度和元素的数组对象
3. 解析完成之前要对符号引用进行验证，确认D是否具有对C的访问权限

###### （2）字段解析

对字段的解析需要首先对其所属的类进行解析，因为字段是属于类的，只有在正确解析得到其类的正确的直接引用才能继续对字段的解析。将字段所属的类或接口用C表示。则字段解析的过程：

1. 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用
2. 否则，如果接口中包含了简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用
3. 否则，递归搜索其父类，如果父类包含，则返回引用

###### （3）类方法解析

同字段解析一样，也应先解析出方法所属类或接口的符号引用。解析成功后，表示为类C

1. 如果发现C是个接口，则直接抛出异常
2. 通过1的检测，如果C中有简单名称和描述符都与目标相匹配的方法，则返回这个方法的直接引用
3. 否则，找父类，如果有，则返回这个方法的直接引用
4. 否则，找接口列表，如果有，则说明该类是抽象类，抛出异常
5. 否则，抛出异常

###### （4）接口方法解析

先解析出方法所属类或接口的符号引用。解析成功后，表示为类C

1. 如果发现C是接口而不是类，抛出异常
2. 现在本接口中查找是否有该方法，没有则找父接口，都没有则抛出异常

##### 5.初始化

只有到初始化阶段，才开始执行类定义的Java代码

**初始化阶段是执行类构造器<clinit>()方法的过程**，即对所有**类静态变量进行赋值和执行static{}块的语句**，**按从上到下，先父类后子类的顺序执行**。和实例构造器<init>()方法不同，这里只会对类变量进行初始化。

```java
public static int value = 123;
```

123在初始化阶段赋值。

### 3.类加载器

类加载阶段**“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作**放在Java虚拟机外部实现。实现这个动作的代码模块称为“类加载器”。

