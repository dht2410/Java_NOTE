分析对象是否存活算法：
	1.引用计数法：给对象添加引用计数器，增加引用时，计数器加1；引用失效时，计数器减1.无法解决循环引用问题。
	2.可达性分析算法：通过一系列称为GC roots的对象作为起始点向下搜索，可达说明对象存活；反之，对象已死。
可作为GC roots的对象：
	1.栈帧的本地变量表中引用的对象
	2.方法区中类静态属性引用的对象
	3.方法区中常量引用的对象
	4.Native方法引用的对象
4种引用：
	1.强引用。new的对象，只要强引用还存在，就不会垃圾回收。
	2.软引用。还有用但并非必需的对象。在内存溢出前，会把这些对象进行第二次回收。
	3.弱引用。无论内存足够与否，都会回收弱引用对象。
	4.虚引用。为对象设置虚引用的唯一目的就是在这个对象被系统回收时，收到一个系统通知。
回收方法区：
	回收废弃常量和无用的类，效率不高

垃圾收集算法：
	1.标记-清除（Mark-Sweep）：先标记无用对象，然后统一删除。
		问题：效率问题；产生碎片
	2.复制算法：回收时，一次将Eden和一块儿Survivor中存活的对象，一次性复制到另一块Survivor中。
		不够时需要老年代分配担保。
	3.标记-整理（Mark-Compack）：先标记无用对象，然后让存活的对象都向一端移动。
	4.分代收集：新生代一般存活时间很短，所以用复制算法；老年代一般用标记清除或者标记整理。

HotSpot实现：
	1.枚举根节点。这个过程都需要Stop the World。用OopMap数据结构记录下栈和寄存器中哪些地方是引用。
	2.只有在安全点才会生成OopMap。SafePoint一般出现在方法调用、循环跳转、异常跳转等。
	3.安全区域。引用关系没有变的连续SafePoint

垃圾收集器：
	新生代：
		1.Serial:单线程收集。需要STW，采用复制算法。
		2.ParNew: Serial的多线程版本。
		3.Parallel Scavenge:并行处理。着眼点在吞吐量，即收集时间与CPU执行用户代码时间之比小。
	老年代：
		1.Serial Old: Serial的老年代版本。需要STW，采用标记-整理算法。
		2.Parallel Old：Parallel Scavenge的老年代版本。
		3.CMS（Concurrent Mark Sweep）：并发标记清除。分为初始标记、并发标记、重新标记和并发清除这四个过程。
			初始标记和重新标记需要STW，但时间短。另外两个过程可以和用户线程并发执行。
			缺点:对CPU资源敏感，无法处理浮动垃圾（并发清除阶段产生的垃圾，需要下次收集），标记清除算法出现碎片
	G1：
		分为初始标记、并发标记、最终标记和筛选回收
		分代收集保留
		从整体看是基于“标记整理算法”，因此不会产生内存碎片
		可预测停顿
	
	内存分配与回收：
		1.对象优先在Eden分配，Eden不够用了，虚拟机将触发Minor GC，如果还是不够用，则会放到Survivor空间，
		如果还不够，则分配担保进入老年代
		2.大对象直接进入老年代。可设置最大参数保证，这么做是为了降低新生代复制的频率
		3.长期存活的对象进入老年代。每个对象有一个对象年龄，在Survivor中，每经过一个Minor GC，Age增加1，增加到15，就会移入老年代
		4.同年对象达到Survivor空间的一半，则进入老年代
		5.分配担保。Survivor无法容纳的对象进入老年代。
	
		