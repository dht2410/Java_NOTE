TCP

1.依赖可靠数据传输原理，包括差错检测、重传、累积确认、定时器以及用于序号和确认号的首部字段

2.面向连接的。在一个进程与另一个进程通信之前，要实现“握手”。连接状态完全保留在两个端系统间。
  全双工服务，可以互传。
  点对点的，只能两两配对
  运输层协议都是进程与进程间通信

三次握手：客户机发送一个特殊的报文，服务器用另一个特殊的报文来回应，并提供缓存和变量（可造成SYN洪泛攻击）
		最后客户机用第三个报文作为响应
		在此过程中，前两个报文不承载有效载荷，第三个报文可以承载有效载荷，即可以承载应用层数据

TCP连接组成：一台主机的缓存、变量和与一个进程连接的套接字
			另一台主机的缓存、变量和与一个进程连接的套接字

TCP报文：包括首部字段和数据字段
		首部字段包括源端口号、目的端口号、序号、确认号、接收窗口、检验和、首部长度、RST和SYN和FIN比特等
		序号是该报文首字节的字节流编号，确认号是下一个希望得到的对方发送的序号，如果是43，则表示0-42均已正确收到

TCP可靠数据传输：
	由于网络层服务（IP服务）是不可靠的，因此运输层的报文也会有各种问题，TCP确保一个进程
	从其接收缓存中读取非损坏的、无间隔的、非冗余的、有序的数据流
	与发送和重传有关的主要事件：从上层接到数据、超时、收到ACK确认（累积确认）
	
	重传：1.加倍超时间隔，防止拥塞
		  2.快速重传。TCP不进行否定确认，如果接收方有比期望序号大的失序报文到达，则立刻发送冗余ACK
					  若TCP接到3个冗余ACK，则执行快速重传
	
	会有累积确认，但也会有接收缓存，因此可把TCP重传看作GBN和选择重传的结合

TCP流量控制
	接收数据放在接收缓存中，如果接收速率高于读取速率，则会缓存溢出
	TCP让发送方维护一个称为接收窗口的变量提供流量控制
	RcvBuffer：缓存大小
	LastByteRead: 最后一个读走的字节
	LastByteRcv: 从网络中到达放入缓存中的最后一个数据流字节
	
	剩余空间RcvWindow=RcvBuffer-(LastByteRcv-LastByteRead)
	主机A给B发送数据，B把当前的RcvWindow发给A，A跟踪两个变量LastByteSent和LastByteAcked，
	LastByteSent-LastByteAcked为已发送但未确定接收的数据大小
	应保证LastByteSent-LastByteAcked<=RcvWindow
	
	当收到RcvWindow为0，主机A仍然发送只有一个字节数据的报文段
	
	UDP不提供流量控制

TCP连接管理
	三次握手：
		1.客户机向服务器端发送特殊的TCP报文，不含应用层数据。但首部SYN比特被设置为1，并
		  随机选择一个起始序号client_isn放在首部序号字段中。（SYN报文段）
		2.当服务器收到该SYN报文时，为该TCP连接分配TCP缓存和变量，并向客户机发送允许连接的报文段
		  该报文段也不含应用层数据，但该报文首部SYN比特被置为1，确认号字段ACK被置为client_isn+1，选择
		  自己的初始序号server_isn作为序号字段。（SYNACK报文段）
		3.在客户机收到SYNACK报文段后，客户机给该TCP连接分配缓存和变量。同时客户机向服务器发送另一个
		  报文段，对服务器允许连接的报文段进行确认（通过将server_isn+1作为确认号ACK），并且将SYN比特设为1
		  在以后的报文中，SYN都被设为0
		
	四次挥手：
		1.两个进程都可以主动结束TCP连接。假如客户机结束连接，则向服务器发送一个特殊的TCP报文，将4
		  首部FIN比特设置为1
		2.服务器收到该报文后，向客户机发送一个确认报文段ACK
		3.传完该传的数据后，服务器发送其终止报文段，FIN比特置为1
		4.客户机收到此终止报文段，向服务器发送确认报文段ACK

为什么需要三次握手：
	1.为了防止已失效的请求报文段又传到了服务器，因此产生错误和资源消耗。如果采用两次握手，那么如果
	  某一个请求由于网络延迟，等到正常TCP连接已经断开后才到达服务器，那么服务器又会新开一个TCP连接，但
	  这个回复报文客户机不会响应，这就会造成服务器内存资源的消耗。
	2.两次握手，客户机和服务器就客户机的初始序列号达成一致，但服务器无法确认客户机得到自己的初始序列号，
	  也就无法确认自己发过去的数据客户机完全收到了。
	  
不正常情况：
	1.三次握手第一个包丢包，即A发送给B的请求连接丢包，则A收不到B的同步报文，会超时重传；
	2.三次握手第二个包丢包，B收不到A的确认报文，会超时重传
	3.三次握手第三个包丢包
	  a.如果双方都没有数据发送，那么B会超时重传
	  b.如果B收到了A的Date+ACK，则自动切换为ESTABLISHED状态，接收A的Date
	  c.假定B有数据发送，数据发送不了，会一直周期性超时重传SYN+ACK，直到收到A的确认才可以发送数据
	4.若服务器收到的TCP报文首部目的端口号和IP地址与运行的套接字不匹配，那么就会返回一个特殊报文，
	该报文将RST比特置为1

TCP拥塞控制
	拥塞原因及开销：
	1.当分组到达速率接近链路容量时，分组经历巨大的排队时延
	2.当考虑实际路由器缓存有限，则自然会有丢包重传造成的开销
	3.发送方遇到大时延时的快速重传，当原本的包顺利到达时，会造成不必要的开销
	4.当一个分组沿着一条路径被丢弃时，每个上游路由器转发该分组时的开销就成了无用功
	
	拥塞控制原理：
	1.端到端拥塞控制（TCP使用）
	2.网络辅助的拥塞控制。由网络交换机来设置数据某个比特为1来表示网络拥堵，接收方接到此信号后，
	就会把该信号发送给发送方，由发送方来减小流量。
	
	TCP拥塞控制：
		通过让发送方感受网络拥塞程度来控制流量发送速率。因此需解决三个问题：
		1.TCP发送方如何感知拥塞程度
		2.TCP发送方如何限制发送流量速率
		3.当感知到拥塞，通过何种算法改变发送速率
		
		TCP拥塞机制让每一端都记录一个拥塞窗口变量CongWin，对发送速率进行限制
		有LastByteSent - LastByteAcked <=min{CongWin, RcvWindow}
		
		问题1回答：
		TCP定义丢包：要么超时，要么收到3个冗余ACK，此时发送方就认为从发送到接收的路径上出现拥塞
		
		问题2、3回答：
		TCP收到正常的确认到达，则会增加拥塞窗口的长度（即增加传输速率）。当确认到达得快，则增加得快
		当确认到达得慢，则增加得慢。利用TCP拥塞控制算法。
		1.加性增、乘性减
		乘性减：当发生一次丢包事件，就把CongWin减半；连续发生，连续减半
		加性增：每次收到一个ACK，则把CongWin增加一个MSS（MSS/CongWin）字节。使得每个往返时延内增加一个MSS。
		这种算法使得CongWin的值随时间呈锯齿状
		2.慢启动
		在一个TCP连接开始时，CongWin被设置为1个MSS，如果按加性增则会很慢。因此，当初始阶段时，
		TCP采用指数增加的方式，每过一个RTT，传输速率增加一倍。直到遇到丢包事件，则才转化成1所述的加性增乘性减。
		3.对超时事件作出反应
		TCP对超时和对收到三个冗余ACK的反应略有不同。对收到三个冗余，则过程如1所述，但对于超时确认的丢包，
		TCP发送方进入一个慢启动状态，即将CongWin设置为1MSS，过程如2和1所述。
		TCP维护一个变量Threshold，称为阈值，设置为CongWin相同的大小（但初始值很多，为没有初始反应）。
		每发生一个丢包事件，Threshold减半。当超时慢启动后，CongWin到达Threshold后变成锯齿增长。
		
		对超时和对收到三个冗余ACK的反应不同的原因？
		收到三个冗余，则说明网络可以顺利交付一部分分组的，所以拥塞程度可能不会有超时那么严重。
		
公平性问题：
	1.UDP没有拥塞控制机制，因此UDP会压制TCP流量
	2.某应用开多条并行TCP，压制其他基于TCP的应用的流量
		
		  


		  