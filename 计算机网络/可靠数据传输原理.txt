rdt(reliable data transfer)
1.rdt 1.0
	假设底层信道完全可靠，即无比特错误，无分组丢失
	发送方和接受方均只有一种状态：发送方等待上层的调用，当上层调用，发出分组；
	接收方等待来自下层的调用，当下层调用时，提取下层数据并将其发送给上层
2.rdt 2.0 停等协议
	若分组中比特受损，三种解决办法
	①差错检测   ②接收方反馈   ③重传
		考虑到接收方反馈的信息也有可能受损，当发送方接收到含混不清的反馈信号时，选择重传，为保证
	重传应付冗余，对每个重传的分组编号，因为假设没有丢包，因此相邻两个编号分别为0和1。
		发送方此时有4种状态：等待上层调用发送0，等待接受0的ACK或NCK，等待上层调用发送1，等待接收1的ACK或NCK
		接收方此时有2种状态：等待来自下层的0，等待来自下层的1
3.rdt 3.0 比特交替协议
	若分组中比特受损，并且还会丢包
	设置一个最长时延值，发送方发送后启动倒计数定时器，到达最长时延值后，重传分组

可靠数据传输要点：检验和、序号、定时器、ACK和NCK

停等协议不足：利用率不足，可通过流水线技术改进，此时需要改变的是
				1.必须增加序号范围
				2.增加缓存，发送方至少应缓存未被确认收到的分组
				3.恢复差错的方式：回退N步，选择重传

1.回退N步（GBN）
	最早的未被确认的分组序号记为基序号base，下一个待发送的序号记为next
	可把分组分为4部分
		1.[0,base-1] 已经确认的
		2.[base,next-1] 已发送，未被确认
		3.[next,base+N-1] 要被立即发送的分组
		4.大于base+N 不允许被发送，除非收到base被收到的确认信号
	N被称为窗口长度，可以从前向后滑动
	GBN发送方动作：
		1.当上层调用send()，检查窗口中分组数量，不足N，则发送，等于N，则缓存或退给上层
		2.收到ACK确认，累积确认，表明已正确收到序号n以前的所有分组，收到一个，则定时器重启一次
		3.超时，则回退N步，意思是重新发送已发送未被确认的分组
	GBK接收方动作：
		累积确认，只有收到expectednext序号的分组后，才会收下并返回ACK，其他情况，返回最近接收的分组的ACK
	不足：一个单分组的差错就会导致全部重传

2.选择重传
	让发送方仅重传那些它怀疑在接收方出错的分组
	发送方动作：
		1.当上层调用send()，检查窗口中分组序号，如果该序号在窗口内，则发送，否则缓存或退给上层
		2.收到ACK确认，若该序号在窗口内，则标记为已收到，若不在，则丢弃。如果接收到的序号等于base，
		  则向后移动窗口到最早的未被确认的分组处
		3.超时。对每个分组都设置定时器，超时则重发。
	接收方动作：
		1.当接收到[base,base+N-1]，分两种情况：若是[base+1,base+N-1],则缓存；若是base，则连同后面
		  连续的分组一起交给上一层，窗口后移至最先一个还未到的分组
		2.当接收到[0,base-1]，必须返回一个收到该分组的序号ACK
		3.其他情况，丢弃
		
可靠数据传输机制：
	1.检验和
	2.定时器
	3.序号
	4.ACK和NCK
	5.窗口和流水线
	//明白其具体作用以及如何逐步添加进来