## 系统调用

接口让应用程序受限地访问硬件设备

实际上这些接口为了保证系统的稳定可靠，避免应用程序肆意妄为

- 为用户空间提供了硬件的抽象接口
- 系统调用保证了系统的稳定和安全

应用程序调用顺序，应用程序接口调用C库，C库完成系统调用

每一个系统调用都对应一个系统调用号

系统调用通知内核的方式是用**软中断**实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理程序，即系统调用程序system_call。同时把系统调用号一并传给内核。系统调用号放在eax寄存器上。系统调用的参数，也会像系统调用号一样，放在寄存器上。如果超过5个参数，那么应该用一个单独的寄存器放指向所有这些参数在用户空间地址的指针。

给用户空间的返回值也通过寄存器传递。也被放在eax寄存器上。

系统调用返回的时候，控制权依然在system_call中，它最终负责切换到用户空间。



**内核态与用户态：**

（1）**当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。**此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，**执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。**

（2）**当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）**。此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。



程序在执行过程中通常有用户态和内核态两种状态，CPU对处于内核态根据上下文环境进一步细分，因此有了下面三种状态：

（1）内核态，运行于进程上下文，内核代表进程运行于内核空间。
（2）内核态，运行于中断上下文，内核代表硬件运行于内核空间。
（3）用户态，运行于用户空间。

一个进程的上下文可以分为三个部分:**用户级上下文、寄存器上下文以及系统级上下文**。

（1）用户级上下文: 正文、数据、用户堆栈以及共享存储区；
（2）寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；
（3）系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。

当发生进程调度时，进行进程切换就是上下文切换(context switch).操作系统必须对上面提到的**全部信息进行切换**，新调度的进程才能运行。而系统调用进行的模式切换(mode switch)。模式切换与进程切换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是切换**进程寄存器上下文的切换**。

硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。**所谓的“ 中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。**中断时，内核不代表任何进程运行，它一般只访问系统空间，而不会访问进程空间，内核在中断上下文中执行时一般不会阻塞。