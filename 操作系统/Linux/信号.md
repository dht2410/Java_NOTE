## 信号

信号的本质是一种进程间的通信。进程之间约定好：如果发生了某件事情T（trigger），就向目标进程（destination process）发送某特定信号X，而目标进程看到X，就意识到T事件发生了，目标进程就会执行相应的动作A（action）。

#### 流程

1. 目标进程首先约定，只要收到SIGHUP，就执行重新加载配置文件的动作。这个行为称为信号的安装（installation），或者信号处理函数的注册。安装好了之后，因为信号是异步事件，不知道何时会发生，所以目标进程依然正常地干自己的事情。
2. 某年某月的某一天，管理员突然改变了配置文件，想通知这个目标进程，于是就向目标进程发送了信号。他可能在终端执行了kill-SIGHUP命令，也可能调用了C的API，不管怎样，信号产生了。
3. 这时候，Linux内核收到了产生的信号，然后就在目标进程的进程描述符里记录了一笔：收到信号SIGHUP一枚。
4. Linux内核会在适当的时机，将信号递送（deliver）给进程。在内核收到信号，但是还没有递送给目标进程的这一段时间里，信号处于挂起状态，被称为挂起（pending）信号，也称为未决信号。内核将信号递送给进程，进程就会暂停当前的控制流，转而去执行信号处理函数。这就是一个信号的完整生命周期。

#### 信号的产生

作为进程间通信的一种手段，进程之间可以互相发送信号，然而发给进程的信号，通常源于内核，包括：
·硬件异常。
·终端相关的信号。
·软件事件相关的信号。

#### 软件

与子进程退出向父进程发送信号相反，有时候，进程希望父进程退出时向自己发送信号，从而可以得知父进程的退出事件。Linux也提供了这种机制。
每一个进程的进程描述符task_struct中都存在如下成员变量：

```c
int pdeath_signal; /* The signal sent when the parent dies */
```

#### 信号的默认处理函数

很多信号尤其是传统的信号，都会有默认的信号处理方式。如果我们不改变信号的处理函数，那么收到信号之后，就会执行默认的操作。
信号的默认操作有以下几种：
·显式地忽略信号：即内核将会丢弃该信号，信号不会对目标进程产生任何影响。
·终止进程：很多信号的默认处理是终止进程，即将进程杀死。
·生成核心转储文件并终止进程：进程被杀死，并且产生核心转储文件。核心转储文件记录了进程死亡现场的信息。用户可以使用核心转储文件来调试，分析进程死亡的原因。
·停止进程：停止进程不同于终止进程，终止进程是进程已经死亡，但是停止进程仅仅是使进程暂停，将进程的状态设置成TASK_STOPPED，一旦收到恢复执行的信号，进程还可以继续执行。
·恢复进程的执行：和停止进程相对应，某些信号可以使进程恢复执行。

![image-20200930153134079](C:\Users\dht24\AppData\Roaming\Typora\typora-user-images\image-20200930153134079.png)

1-31为不可靠信号，34-64为可靠信号。一一对应。

对于不可靠信号，内核用位图来记录该信号是否处于挂起状态。

对于可靠信号，内核内部有队列来维护，如果收到可靠信号，内核会将信号挂到相应的队列中，因此不会丢失。