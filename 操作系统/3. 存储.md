## 存储管理

### 地址空间

地址空间：进程可用于寻址内存的一系列地址。

处理内存超载的方法：

- 交换技术。把不此刻不运行的进程调进磁盘。
- 虚拟内存。甚至可以使程序只有一部分被调入内存。

![image-20200508160540280](C:\Users\dht24\AppData\Roaming\Typora\typora-user-images\image-20200508160540280.png)

预留的空间如果用完了，进程或者必须移动到足够大的空闲区中（它可以被交换出内存直到内存中有足够的空间），或者结束该进程。

**空闲内存管理：**

- 位图。如果以4字节为分配单元，则位图占内存1/33
- 链表。链表的每个节点包含：空闲区或进程的指示位，起始地址，长度和指向下个节点的指针。假设知道要为进程分配多大的内存，则可以用首次适配原则，从头搜索可以装入的空闲区。

### 虚拟内存

**虚拟内存的基本思想是：**

- 每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页或页面（page）。
- 每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。
- 当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。
- 当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。
- 当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。

在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到内存管理单元（Memory Management Unit，MMU），MMU把虚拟地址映射为物理内存地址。

如果某个地址映射不存在，也就是说该地址不在物理内存中，而在磁盘中。则此时，则CPU陷入操作系统，这个中断称为**缺页中断**。选择一个不太使用的页进行交换。

**虚拟地址到物理地址的映射：**

虚拟地址被分成虚拟页号（高位部分）和偏移量（低位部分）两部分。MMU以虚拟页号为索引获得页框号（物理地址中的页）。页框号＋偏移量确定物理地址。

**页表项：**

**每个进程都有自己的页表。**页表保存在内存中。

在MMU中存储的页表每条键值对的值。包含

- 页框号
- 在/不在位。即在不在内存
- 保护位。允许什么类型的访问
- 访问位。看还在不在被访问，用于缺页中断时选择谁下去
- 修改位。如果修改过，被换下去时就要覆盖原来的

如何快速从虚拟地址映射到物理地址：

采用TLB（转换检测缓冲区），一种硬件设备。可以直接由虚拟地址查到物理地址。

针对大内存的页表：

多级页表。分顶级页表和二级页表。避免把全部页面一直保存在内存中。

### 页面置换算法

（1）NRU（Not Recently Used）算法

检查页表项的访问位和修改位。共四种情况。NRU随机挑选一个编号最小的类将其替换。

（2）LRU（Least Recently Used）算法

维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表位。但每次访问内存后都要更新整个链表，消耗太大。

（3）NFU（Not Frequently Used）算法

改进后为老化算法。每次时钟中断时，将页面计数器的值右移一位，把R位的值加到最左端。替换值最小的页面。

### 分页系统的设计

全局or局部：局部是指当某一进程引发缺页中断时，替换只发生在进程内部，因此每个进程所占空间不变。全局是指替换发生在所有进程间。

负载控制：当进程过多，将一部分进程交换到磁盘。

页面大小选取：小的可以减小内部碎片，但可能和磁盘的交换次数多了。

分离指令空间和数据空间



**进程运行时：**

- 当调度一个进程执行时，必须为新进程重置MMU，刷新TLB，以清除以前的进程遗留的痕迹。
- **新进程的页表必须成为当前页表，通常可以通过复制该页表或者把一个指向它的指针放进某个硬件寄存器来完成。**
- 有时，在进程初始化时可以把进程的部分或者全部页面装入内存中以减少缺页中断的发生，例如，PC（程序计数器）所指的页面肯定是需要的。
- 操作系统备份程序计数器的值。以便缺页被调回后继续执行这一句。
- 操作系统必须把有关页表和磁盘交换区的信息存储在进程表中。

页面在磁盘中的存储：

在磁盘上设置单独的交换分区，一种方式是在磁盘划出和进程同样大小的块。将进程整个复制进去。按逻辑地址连续存储。因此在缺页时，只需要获得虚拟地址的偏移量和记录的磁盘该进程块的起始地址就能确定该地址。

另一种是需要换出去的时候记录。散着装，进程表中记录在磁盘中的位置。

### **段（Segment）**

段是一个逻辑实体，程序员知道这一点并把它作为一个逻辑实体来使用。一个段可能包括一个过程、一个数组、一个堆栈、一组数值变量，但一般它不会同时包含多种不同类型的内容。

**程序段、数据段、堆栈段**

因为每个段是一个为程序员所知道的逻辑实体，比如一个过程、一个数组或一个堆栈，故不同的段可以有不同种类的保护。

单纯段实现，由于大小不均，会产生碎片。

**段+页的实现：把段看成虚拟内存，对段进行分页。**

MULTICS中一个地址由两部分构成：段和段内地址。段内地址又进一步分为页号和页内的字。



