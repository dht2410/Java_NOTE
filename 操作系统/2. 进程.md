## 进程

一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。从概念上说，每个进程拥有它自己的虚拟CPU。

**进程的状态（3态，5态的话加停止态）：**

1. 运行态（占用CPU）
2. 就绪态（可运行）
3. 阻塞态

为了实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表（process table）。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息。



## 线程

在传统操作系统中，每个进程有一个地址空间和一个控制线程。事实上，这几乎就是进程的定义。

并行实体**共享同一个地址空间**和所有可用数据

理解进程的一个角度是（**资源角度**），用某种方法把相关的资源集中在一起。另一个概念是（**执行角度**），进程拥有一个执行的线程，通常简写为线程（thread）。进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。

线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。**在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。**多线程共享进程的地址空间，好比多进程共享计算机的文件资源。**线程也是轻量级进程。**

![image-20200506214403970](C:\Users\dht24\AppData\Roaming\Typora\typora-user-images\image-20200506214403970.png)

第一列表项是进程的属性，而不是线程的属性。例如，如果一个线程打开了一个文件，该文件对该进程中的其他线程都可见，这些线程可以对该文件进行读写。

每个线程有自己的堆栈。栈帧。

线程可以在用户空间和内核空间实现。即把线程表放在用户空间（所属的进程记录）还是内核空间。

用户级线程优势：

- 切换线程时，不用陷入内核查表。只要堆栈指针和程序计数器一被切换，新的线程就又自动投入运行。
- 允许每个进程有自己定制的调度算法

问题是：如果一个线程开始运行，那么在该进程中的其他线程就不能运行。

内核级线程：每个进程中也没有线程表。相反，**在内核中有用来记录系统中所有线程的线程表。**当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。

**JVM在本机操作系统之上运行，并且JVM规范未指定用于将Java线程映射到内核线程的模型。此决定取决于JVM实现，可能是一对一，多对多或多对一。**

**Linux中，JVM线程跟内核轻量级进程有一一对应的关系**。

**Java线程在Windows及Linux平台上的实现方式，现在看来，是内核线程的实现方式。**

## 进程间通信

三个问题：

- 如何通信
- 如何处理冲突
- 顺序

**后两个同样适用于线程。**

处理竞争关系：设置临界区，互斥

互斥的方案：

- 屏蔽中断。屏蔽了时钟中断，则不会进行进程间的切换。这个方法不好
- 锁
- 自旋锁。忙等待，消耗CPU
- 锁总线。其他进程不允许访问被锁住的地址

睡眠和唤醒：

- 生产者消费者模式

**信号量：**

​		一个信号量的取值可以为0（表示没有保存下来的唤醒操作）或者为正值（表示有一个或多个唤醒操作）。解决多生产者和消费者模型。信号量的up和down操作是睡眠和唤醒的一般形式。

​	执行down操作(P)，如果信号量值大于0，则减1并继续；如果是0，则进程睡眠

​	执行up操作(V)，对信号量的值增1。如果有在信号量上等待的进程，则唤醒进程。信号量还为0.

信号量的另一种用途是用于实现同步。决定顺序。与互斥用法不同。

在使用信号量的系统中，隐藏中断的最自然的方法是为每一个I/O设备设置一个信号量，其初值为0。在启动一个I/O设备之后，管理进程就立即对相关联的信号量执行一个down操作，于是进程立即被阻塞。**当中断到来时，中断处理程序随后对相关信号量执行一个up操作**，从而将相关的进程设置为就绪状态。

**消息传递：**

进程间通信，包括网络。send()和receive()函数。

**屏障：**

联想JAVA中屏障的实现。多个线程都到达后，屏障才被解除。



## 调度

当内核管理线程的时候，调度经常是按线程级别的，与线程所属的进程基本或根本没有关联。

为了选取正确的进程运行，调度程序还要考虑CPU的利用率，因为**进程切换的代价是比较高的**：

1. 首先用户态必须切换到内核态；
2. 然后要保存当前进程的状态，包括在进程表中存储寄存器值以便以后重新装载。
3. 在许多系统中，内存映像（例如，页表内的内存访问位）也必须保存；接着，通过运行调度算法选定一个新进程；
4. 之后，应该将新进程的内存映像重新装入MMU；最后新进程开始运行。
5. 除此之外，进程切换还要使整个内存高速缓存失效，强迫缓存从内存中动态重新装入两次（进入内核一次，离开内核一次）。

**当一个进程等待外部设备完成工作而被阻塞时，才是I/O活动。**

典型的计算密集型进程具有较长时间的CPU集中使用和较小频度的I/O等待。I/O密集型进程具有较短时间的CPU集中使用和频繁的I/O等待。有必要指出，随着CPU变得越来越快，更多的进程倾向为I/O密集型。

调度算法：

- 非抢占式调度算法。进程运行直到被阻塞或结束或自动释放CPU。
- 抢占式调度算法。一个时间段后发出时钟中断，CPU控制返回给调度程序。调度程序决定谁来运行。

在交互式用户环境中，为了避免一个进程霸占CPU拒绝为其他进程服务，抢占是必需的。

场景：

- 批处理
- 交互式系统
- 实时系统

批处理系统调度算法：

1. 先来先服务（后来的加入链表尾）
2. 最短时间优先
3. 最短剩余时间优先（抢占式）

交互式系统调度算法：

1. **轮转制度。时间片，时间片到达或发生阻塞时，切换进程。**时间片设得太短会导致过多的进程切换，降低了CPU效率；而设得太长又可能引起对短的交互请求的响应时间变长。将时间片设为20ms～50 ms通常是一个比较合理的折中。
2. 优先级调度。动态赋予优先级。同一优先级采用轮转制度。如果不偶尔对优先级进行调整，则低优先级进程很可能会产生饥饿现象。
3. 多级队列优先。优先级从高到低为，终端、IO、短进程、长进程

调度机制和调度策略分离：

​		调度机制由内核决定，调度策略由用户决定

### 线程调度

**当若干进程都有多个线程时，就存在两个层次的并行：进程和线程。**在这样的系统中调度处理有本质差别，这取决于所支持的是用户级线程还是内核级线程（或两者都支持）。

线程调度分为用户级线程和内核级线程。

**用户级线程在调度时，时间片分给进程。**进程内部调度线程。同一时间片内所运行的线程只属于同一进程。切换方便，不用陷入内核态。不能响应时钟中断。可以有自己内部的线程调度策略。

**内核级线程在调度时，以线程为基本单位。**可以在不同进程的线程间切换。切换时要陷入内核态（要修改内存镜像，清除高速缓存）。可以响应时钟中断。



## 经典IPC问题

哲学家就餐：有限资源的竞争问题

读者和写者：数据库访问