## 进程

一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。从概念上说，每个进程拥有它自己的虚拟CPU。

**进程的状态（3态，5态的话加停止态）：**

1. 运行态（占用CPU）
2. 就绪态（可运行）
3. 阻塞态

为了实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表（process table）。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息。



## 线程

在传统操作系统中，每个进程有一个地址空间和一个控制线程。事实上，这几乎就是进程的定义。

并行实体**共享同一个地址空间**和所有可用数据

理解进程的一个角度是（**资源角度**），用某种方法把相关的资源集中在一起。另一个概念是（**执行角度**），进程拥有一个执行的线程，通常简写为线程（thread）。进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。

线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。**在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。**多线程共享进程的地址空间，好比多进程共享计算机的文件资源。**线程也是轻量级进程。**

![image-20200506214403970](C:\Users\dht24\AppData\Roaming\Typora\typora-user-images\image-20200506214403970.png)

第一列表项是进程的属性，而不是线程的属性。例如，如果一个线程打开了一个文件，该文件对该进程中的其他线程都可见，这些线程可以对该文件进行读写。

每个线程有自己的堆栈。栈帧。

线程可以在用户空间和内核空间实现。即把线程表放在用户空间（所属的进程记录）还是内核空间。

用户级线程优势：

- 切换线程时，不用陷入内核查表。只要堆栈指针和程序计数器一被切换，新的线程就又自动投入运行。
- 允许每个进程有自己定制的调度算法

问题是：如果一个线程开始运行，那么在该进程中的其他线程就不能运行。

内核级线程：每个进程中也没有线程表。相反，**在内核中有用来记录系统中所有线程的线程表。**当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。

**JVM在本机操作系统之上运行，并且JVM规范未指定用于将Java线程映射到内核线程的模型。此决定取决于JVM实现，可能是一对一，多对多或多对一。**

**Linux中，JVM线程跟内核轻量级进程有一一对应的关系**。

**Java线程在Windows及Linux平台上的实现方式，现在看来，是内核线程的实现方式。**

## 进程间通信

三个问题：

- 如何通信
- 如何处理冲突
- 顺序

**后两个同样适用于线程。**

处理竞争关系：设置临界区，互斥

互斥的方案：

- 屏蔽中断。屏蔽了时钟中断，则不会进行进程间的切换。这个方法不好
- 锁
- 自旋锁。忙等待，消耗CPU
- 锁总线。其他进程不允许访问被锁住的地址

睡眠和唤醒：

- 生产者消费者模式

**信号量：**

​		一个信号量的取值可以为0（表示没有保存下来的唤醒操作）或者为正值（表示有一个或多个唤醒操作）。解决多生产者和消费者模型。信号量的up和down操作是睡眠和唤醒的一般形式。

​	执行down操作(P)，如果信号量值大于0，则减1并继续；如果是0，则进程睡眠

​	执行up操作(V)，对信号量的值增1。如果有在信号量上等待的进程，则唤醒进程。信号量还为0.

信号量的另一种用途是用于实现同步。决定顺序。与互斥用法不同。

在使用信号量的系统中，隐藏中断的最自然的方法是为每一个I/O设备设置一个信号量，其初值为0。在启动一个I/O设备之后，管理进程就立即对相关联的信号量执行一个down操作，于是进程立即被阻塞。**当中断到来时，中断处理程序随后对相关信号量执行一个up操作**，从而将相关的进程设置为就绪状态。

**消息传递：**

进程间通信，包括网络。send()和receive()函数。

**屏障：**

联想JAVA中屏障的实现。多个线程都到达后，屏障才被解除。



## 调度

当内核管理线程的时候，调度经常是按线程级别的，与线程所属的进程基本或根本没有关联。

为了选取正确的进程运行，调度程序还要考虑CPU的利用率，因为**进程切换的代价是比较高的**：

1. 首先用户态必须切换到内核态；
2. 然后要保存当前进程的状态，包括在进程表中存储寄存器值以便以后重新装载。
3. 在许多系统中，内存映像（例如，页表内的内存访问位）也必须保存；接着，通过运行调度算法选定一个新进程；
4. 之后，应该将新进程的内存映像重新装入MMU；最后新进程开始运行。
5. 除此之外，进程切换还要使整个内存高速缓存失效，强迫缓存从内存中动态重新装入两次（进入内核一次，离开内核一次）。

**当一个进程等待外部设备完成工作而被阻塞时，才是I/O活动。**

典型的计算密集型进程具有较长时间的CPU集中使用和较小频度的I/O等待。I/O密集型进程具有较短时间的CPU集中使用和频繁的I/O等待。有必要指出，随着CPU变得越来越快，更多的进程倾向为I/O密集型。

调度算法：

- 非抢占式调度算法。进程运行直到被阻塞或结束或自动释放CPU。
- 抢占式调度算法。一个时间段后发出时钟中断，CPU控制返回给调度程序。调度程序决定谁来运行。

在交互式用户环境中，为了避免一个进程霸占CPU拒绝为其他进程服务，抢占是必需的。

场景：

- 批处理
- 交互式系统
- 实时系统

批处理系统调度算法：

1. 先来先服务（后来的加入链表尾）
2. 最短时间优先
3. 最短剩余时间优先（抢占式）

交互式系统调度算法：

1. **轮转制度。时间片，时间片到达或发生阻塞时，切换进程。**时间片设得太短会导致过多的进程切换，降低了CPU效率；而设得太长又可能引起对短的交互请求的响应时间变长。将时间片设为20ms～50 ms通常是一个比较合理的折中。
2. 优先级调度。动态赋予优先级。同一优先级采用轮转制度。如果不偶尔对优先级进行调整，则低优先级进程很可能会产生饥饿现象。
3. 多级队列优先。优先级从高到低为，终端、IO、短进程、长进程

调度机制和调度策略分离：

​		调度机制由内核决定，调度策略由用户决定

### 线程调度

**当若干进程都有多个线程时，就存在两个层次的并行：进程和线程。**在这样的系统中调度处理有本质差别，这取决于所支持的是用户级线程还是内核级线程（或两者都支持）。

线程调度分为用户级线程和内核级线程。

**用户级线程在调度时，时间片分给进程。**进程内部调度线程。同一时间片内所运行的线程只属于同一进程。切换方便，不用陷入内核态。不能响应时钟中断。可以有自己内部的线程调度策略。

**内核级线程在调度时，以线程为基本单位。**可以在不同进程的线程间切换。切换时要陷入内核态（要修改内存镜像，清除高速缓存）。可以响应时钟中断。



## 经典IPC问题

哲学家就餐：有限资源的竞争问题

读者和写者：数据库访问



## Linux中的进程和线程

每一个进程都有一个运行用户程序的用户模式。但是当它的某一个线程调用系统调用之后，进程会陷入内核模式并且运行在内核上下文中，它将使用不同的内存映射并且拥有对所有机器资源的访问权。**它还是同一个线程**，但是现在拥有更高的权限，同时拥有自己的内核堆栈以及内核程序计器。

在Linux系统内核中，进程通过数据结构task_struct被表示成任务（task）。task_struct里面有文件描述符表数据结构files_struct。

进程描述符task_struct包含的信息：

1. 调度参数。优先级
2. 内存映射。指向代码、数据、堆栈段或页表的指针。当进程不在内存当中时，关于如何在磁盘上找到这些数据的信息也被保存在这里。
3. 信号。掩码显示了哪些信号被忽略、哪些信号需要捕捉、哪些信号被暂时阻塞以及哪些信号在传递当中。
4. 机器寄存器。当内核陷阱发生时，机器寄存器的内容（也包括被使用了的浮点寄存器的内容）会被保存。
5. 系统调用状态。关于当前系统调用的信息，包括参数和返回值。
6. 文件描述符表。当一个与文件描述符有关的系统调用被调用的时候，文件描述符作为索引在文件描述符表中定位相关文件的i节点数据结构。
7. 统计。指向记录用户、进程占用系统CPU时间的表的指针。一些系统还保存一个进程最多可以占用CPU的时间、进程可以拥有的最大堆栈空间、进程可以消耗的页面数等。
8. 内核堆栈。进程的内核部分可以使用的固定堆栈。
9. 其他。当前进程状态。如果有的话，包括正在等待的事件、距离警报时钟超时的时间、PID、父进程的PID以及其他用户标识符、组标识符等。

对于每一个进程，**一个类型为task_struct的进程描述符是始终存在于内存当中的。**它包含了内核管理全部进程所需的重要信息，如调度参数、已打开的文件描述符列表等。进程描述符从进程被创建开始就一直存在于内核堆栈之中。

**内核将所有进程的任务数据结构组织成一个双向链表。**不需要遍历这个链表来访问进程描述符，PID可以直接被映射成进程的任务数据结构所在的地址，从而立即访问进程的信息。

创建一个新进程的过程非常简单。为子进程创建一个新的进程描述符和用户空间，然后从父进程复制大量的内容。这个子进程被赋予一个PID，并建立它的内存映射，同时它也被赋予了访问属于父进程文件的权利。然后，它的寄存器内容被初始化并准备运行。

把进程描述符的地址存储在一个固定的地方，使得Linux系统只需要进行很少的有效操作就可以找到一个运行中进程的任务数据结构。

**写时复制：**

它们赋予子进程属于它的页表，但是这些页表都指向父进程的页面，同时把这些页面标记成只读。当子进程试图向某一页面中写入数据的时候，它会收到写保护的错误。内核发现子进程的写入行为之后，会为子进程分配一个该页面的新副本，并将这个副本标记为可读、可写。

![image-20200812113707215](C:\Users\dht24\AppData\Roaming\Typora\typora-user-images\image-20200812113707215.png)